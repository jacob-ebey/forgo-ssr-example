{"version":3,"sources":["webpack://forgo-example/./node_modules/forgo-render-to-string/dist/index.js","webpack://forgo-example/./src/App.tsx","webpack://forgo-example/./src/server.tsx","webpack://forgo-example/./src/todos.tsx","webpack://forgo-example/../forgo/dist/index.js","webpack://forgo-example/../forgo/dist/render-to-string.js","webpack://forgo-example/../forgo/jsx-runtime/index.js","webpack://forgo-example/../forgo/node_modules/preact-render-to-string/src/util.js","webpack://forgo-example/external \"fs\"","webpack://forgo-example/external \"http\"","webpack://forgo-example/external \"path\"","webpack://forgo-example/webpack/bootstrap","webpack://forgo-example/webpack/runtime/define property getters","webpack://forgo-example/webpack/runtime/hasOwnProperty shorthand","webpack://forgo-example/webpack/runtime/make namespace object","webpack://forgo-example/webpack/startup"],"names":[],"mappings":";;;;;;;;;AAAA,eAAe,KAAoD,YAAY,CAA+F,CAAC,kBAAkB,aAAa,oCAAoC,YAAY,mBAAmB,KAAK,mBAAmB,sEAAsE,SAAS,wBAAwB,wEAAwE,cAAc,kCAAkC,iBAAiB,WAAW,KAAK,WAAW,UAAU,gBAAgB,EAAE,MAAM,gBAAgB,EAAE,MAAM,kBAAkB,EAAE,MAAM,iBAAiB,EAAE,MAAM,cAAc,SAAS,oBAAoB,kDAAkD,mBAAmB,+FAA+F,MAAM,cAAc,SAAS,gBAAgB,WAAW,4JAA4J,GAAG,iBAAiB,gBAAgB,mEAAmE,OAAO,WAAW,mFAAmF,WAAW,oBAAoB,eAAe,QAAQ,gBAAgB,cAAc,sBAAsB,yCAAyC,qEAAqE,wCAAwC,6CAA6C,sCAAsC,yBAAyB,4EAA4E,iCAAiC,uDAAuD,oFAAoF,OAAO,wBAAwB,IAAI,cAAc,IAAI,MAAM,4CAA4C,SAAS,IAAI,aAAa,MAAM,qBAAqB,mCAAmC,YAAY,WAAW,KAAK,kBAAkB,mBAAmB,+HAA+H,oBAAoB,oBAAoB,UAAU,+EAA+E,kBAAkB,kBAAkB,QAAQ,wGAAwG,gDAAgD,kBAAkB,oDAAoD,wCAAwC,kDAAkD,sCAAsC,SAAS,SAAS,gBAAgB,iBAAiB,IAAI,SAAS,qCAAqC,yBAAyB,UAAU,MAAM,8BAA8B,2DAA2D,8GAA8G,iFAAiF,qCAAqC,mCAAmC,uCAAuC,WAAW,KAAK,WAAW,oBAAoB,oDAAoD,+BAA+B,4BAA4B,oCAAoC,gBAAgB,2BAA2B,IAAI,uBAAuB,6BAA6B,wDAAwD,wFAAwF,uGAAuG;AAC/yH;;;;;;;;;;;;ACDa;AACb,kBAAkB;AAClB,oBAAoB,mBAAO,CAAC,wDAAmB;AAC/C,cAAc,mBAAO,CAAC,gCAAS;AAC/B;AACA;AACA;AACA,yDAAyD;AACzD,SAAS;AACT;AACA;AACA,eAAkB;;;;;;;;;;;;ACXL;AACb,kBAAkB;AAClB,oBAAoB,mBAAO,CAAC,wDAAmB;AAC/C,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,WAAW,mBAAO,CAAC,kBAAM;AACzB,+BAA+B,mBAAO,CAAC,mFAAwB;AAC/D,YAAY,mBAAO,CAAC,4BAAO;AAC3B;AACA;AACA;AACA,iGAAiG,YAAY,eAAe;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iCAAiC,gDAAgD,EAAE;;;;;;;;;;;;AC1BtE;AACb;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB,GAAG,gBAAgB;AACvC,oBAAoB,mBAAO,CAAC,wDAAmB;AAC/C,cAAc,mBAAO,CAAC,qCAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qCAAqC,0BAA0B;AAC9G,6CAA6C,mCAAmC,0CAA0C,UAAU,WAAW,EAAE,GAAG;AACpJ,gDAAgD,mBAAmB,YAAY;AAC/E,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,4CAA4C,uBAAuB;AACnE,SAAS;AACT;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wCAAwC,mDAAmD;AAC1I,0DAA0D,oBAAoB,GAAG,sBAAsB,aAAa;AACpH,SAAS;AACT;AACA;;;;;;;;;;;;AC7Da;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,gBAAgB,GAAG,eAAe,GAAG,aAAa,GAAG,oBAAoB,GAAG,qBAAqB,GAAG,sBAAsB;AAC1H,yBAAyB,mBAAO,CAAC,6DAAoB;AACrD,kDAAiD,CAAC,qCAAqC,0CAA0C,EAAE,EAAE,EAAC;AACtI,iDAAgD,CAAC,qCAAqC,yCAAyC,EAAE,EAAE,EAAC;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6CAA6C;AAC3E;AACA;AACA;AACA,gGAAgG,yBAAyB,4BAA4B;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW,oBAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wCAAwC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sBAAsB;AACvE;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,eAAe,wBAAwB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;AC3fa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,qBAAqB,GAAG,sBAAsB;AAC9C,OAAO,qEAAqE,GAAG,mBAAO,CAAC,mGAAkC;AACzH,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F,qBAAqB;AACrB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,KAAK,4BAA4B,EAiBzC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK,IAAI,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS,EAAE,EAAE;AACzB;AACA,2BAA2B,SAAS,mCAAmC,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA;AACA,4C;;;;;;;;;;;;;;;;AChPO;AACP,UAAU;AACV;AACO;AACP,UAAU;AACV;;;;;;;;;;;;;;;;;;;;;;ACLA;AACO;;AAEA;AACP;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA,yBAAyB,EAAE;AAC3B,yBAAyB,EAAE;AAC3B,2BAA2B,EAAE;AAC7B,0BAA0B,EAAE;AAC5B;AACA;AACA;AACA;AACA;;AAEO;AACP;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,IAAI;AACf,aAAa,MAAM;AACnB;AACA;AACO;AACP;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;;;;;;;;;;;AChFA,gC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,kC;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCrBA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,sF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;UCNA;UACA;UACA;UACA","file":"main.js","sourcesContent":["!function(e,r){\"object\"==typeof exports&&\"undefined\"!=typeof module?r(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],r):r((e||self).forgoRenderToString={})}(this,function(e){function r(){return(r=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var n=arguments[r];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e}).apply(this,arguments)}var n=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;function t(e){\"string\"!=typeof e&&(e=String(e));for(var r=\"\",n=0;n<e.length;n++){var t=e[n];switch(t){case\"<\":r+=\"&lt;\";break;case\">\":r+=\"&gt;\";break;case'\"':r+=\"&quot;\";break;case\"&\":r+=\"&amp;\";break;default:r+=t}}return r}var i=function(e,r){return String(e).replace(/(\\n+)/g,\"$1\"+(r||\"\\t\"))},o=function(e,r,n){return String(e).length>(r||40)||!n&&-1!==String(e).indexOf(\"\\n\")||-1!==String(e).indexOf(\"<\")},a={};function f(e){var r=\"\";for(var t in e){var i=e[t];null!=i&&(r&&(r+=\" \"),r+=\"-\"==t[0]?t:a[t]||(a[t]=t.replace(/([A-Z])/g,\"-$1\").toLowerCase()),r+=\": \",r+=i,\"number\"==typeof i&&!1===n.test(t)&&(r+=\"px\"),r+=\";\")}return r||void 0}function l(e,r){return Array.isArray(r)?r.reduce(l,e):null!=r&&!1!==r&&e.push(r),e}var s={shallow:!0},u=[],c=/^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/;d.render=d;var p=function(e,n){return d(e,r({},s,n))};function d(e,r){return g(e,r)}function g(e,r,n,a,s){if(null==e||\"boolean\"==typeof e)return\"\";if(Array.isArray(e))throw new Error(\"Array vnode not yet supported\");var p,d=e.type,h=e.props,v=!1,y=(r=r||{}).pretty,m=y&&\"string\"==typeof y?y:y?\"\\t\":\"\";if(\"object\"!=typeof e&&!d)return t(e);if(\"function\"==typeof d){if(v=!0,!r.shallow||!n&&!1!==r.renderRootComponent)return g(d(h).render(h,{}),r,!1!==r.shallowHighOrder,a,s);d=(p=d).displayName||p!==Function&&p.name||function(e){var r=(Function.prototype.toString.call(e).match(/^\\s*function\\s+([^( ]+)/)||\"\")[1];if(!r){for(var n=-1,t=u.length;t--;)if(u[t]===e){n=t;break}n<0&&(n=u.push(e)-1),r=\"UnnamedComponent\"+n}return r}(p)}var b,x,w=\"\";if(h){var k=Object.keys(h);r&&!0===r.sortAttributes&&k.sort();for(var S=0;S<k.length;S++){var O=k[S],j=h[O];if(\"children\"!==O){if(!O.match(/[\\s\\n\\\\/='\"\\0<>]/)&&(r&&r.allAttributes||\"key\"!==O&&\"ref\"!==O&&\"__self\"!==O&&\"__source\"!==O&&\"defaultValue\"!==O)){if(\"className\"===O){if(h.class)continue;O=\"class\"}else a&&O.match(/^xlink:?./)&&(O=O.toLowerCase().replace(/^xlink:?/,\"xlink:\"));if(\"htmlFor\"===O){if(h.for)continue;O=\"for\"}\"style\"===O&&j&&\"object\"==typeof j&&(j=f(j)),\"a\"===O[0]&&\"r\"===O[1]&&\"boolean\"==typeof j&&(j=String(j));var A=r.attributeHook&&r.attributeHook(O,j,r,v);if(A||\"\"===A)w+=A;else if(\"dangerouslySetInnerHTML\"===O)x=j&&j.__html;else if(\"textarea\"===d&&\"value\"===O)b=j;else if((j||0===j||\"\"===j)&&\"function\"!=typeof j){if(!(!0!==j&&\"\"!==j||(j=O,r&&r.xml))){w+=\" \"+O;continue}if(\"value\"===O){if(\"select\"===d){s=j;continue}\"option\"===d&&s==j&&(w+=\" selected\")}w+=\" \"+O+'=\"'+t(j)+'\"'}}}else b=j}}if(y){var T=w.replace(/^\\n\\s*/,\" \");T===w||~T.indexOf(\"\\n\")?y&&~w.indexOf(\"\\n\")&&(w+=\"\\n\"):w=T}if(w=\"<\"+d+w+\">\",String(d).match(/[\\s\\n\\\\/='\"\\0<>]/))throw new Error(d+\" is not a valid HTML tag name in \"+w);var _,H=String(d).match(c)||r.voidElements&&String(d).match(r.voidElements),$=[];if(x)y&&o(x)&&(x=\"\\n\"+m+i(x,m)),w+=x;else if(null!=b&&l(_=[],b).length){for(var C=y&&~w.indexOf(\"\\n\"),E=!1,L=0;L<_.length;L++){var R=_[L];if(null!=R&&!1!==R){var F=g(R,r,!0,\"svg\"===d||\"foreignObject\"!==d&&a,s);if(y&&!C&&o(F)&&(C=!0),F)if(y){var M=F.length>0&&\"<\"!=F[0];E&&M?$[$.length-1]+=F:$.push(F),E=M}else $.push(F)}}if(y&&C)for(var N=$.length;N--;)$[N]=\"\\n\"+m+i($[N],m)}if($.length||x)w+=$.join(\"\");else if(r&&r.xml)return w.substring(0,w.length-1)+\" />\";return!H||_||x?(y&&~w.indexOf(\"\\n\")&&(w+=\"\\n\"),w+=\"</\"+d+\">\"):w=w.replace(/>$/,\" />\"),w}d.shallowRender=p,e.default=d,e.render=d,e.renderToStaticMarkup=d,e.renderToString=d,e.shallowRender=p});\n//# sourceMappingURL=index.js.map\n","\"use strict\";\r\nexports.__esModule = true;\r\nvar jsx_runtime_1 = require(\"forgo/jsx-runtime\");\r\nvar todos_1 = require(\"./todos\");\r\nfunction App(props) {\r\n    return {\r\n        render: function (props, args) {\r\n            return jsx_runtime_1.jsx(todos_1.TodoList, {}, void 0);\r\n        },\r\n    };\r\n}\r\nexports[\"default\"] = App;\r\n","\"use strict\";\r\nexports.__esModule = true;\r\nvar jsx_runtime_1 = require(\"forgo/jsx-runtime\");\r\nvar fs = require(\"fs\");\r\nvar path = require(\"path\");\r\nvar http = require(\"http\");\r\nvar forgo_render_to_string_1 = require(\"forgo-render-to-string\");\r\nvar App_1 = require(\"./App\");\r\nvar requestListener = function (req, res) {\r\n    if (req.url === \"/\") {\r\n        res.writeHead(200);\r\n        var html = forgo_render_to_string_1.renderToString(jsx_runtime_1.jsx(App_1[\"default\"], {}, void 0), { pretty: true });\r\n        res.end(\"<!DOCTYPE html>\\n<html lang=\\\"en-us\\\">\\n  <head>\\n    <meta charset=\\\"utf-8\\\" />\\n    <title>Forgo SSR Example</title>\\n    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\" />\\n  </head>\\n  <body>\\n    \" + html + \"\\n    <script src=\\\"main.js\\\"></script>\\n  </body>\\n</html>\\n\");\r\n        return;\r\n    }\r\n    fs.readFile(path.join(process.cwd(), \"dist\", req.url), function (err, data) {\r\n        if (err) {\r\n            res.writeHead(404);\r\n            res.end(JSON.stringify(err));\r\n            return;\r\n        }\r\n        res.writeHead(200);\r\n        res.end(data);\r\n    });\r\n};\r\nvar server = http.createServer(requestListener);\r\nserver.listen(8080, function () { return console.log(\"App started on port 8080\"); });\r\n","\"use strict\";\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nexports.__esModule = true;\r\nexports.TodoListItem = exports.TodoList = void 0;\r\nvar jsx_runtime_1 = require(\"forgo/jsx-runtime\");\r\nvar forgo_1 = require(\"forgo\");\r\nfunction TodoList(props) {\r\n    var todos = [];\r\n    return {\r\n        render: function (props, args) {\r\n            function onTodoAdd(text) {\r\n                todos.push(text);\r\n                forgo_1.rerender(args.element);\r\n            }\r\n            return (jsx_runtime_1.jsxs(\"div\", { children: [jsx_runtime_1.jsx(\"h1\", { children: \"Forgo Todos\" }, void 0),\r\n                    jsx_runtime_1.jsx(\"ul\", { children: todos.map(function (t) { return (jsx_runtime_1.jsx(TodoListItem, { text: t }, void 0)); }) }, void 0),\r\n                    jsx_runtime_1.jsx(AddTodo, { onAdd: onTodoAdd }, void 0)] }, void 0));\r\n        },\r\n    };\r\n}\r\nexports.TodoList = TodoList;\r\nfunction TodoListItem(props) {\r\n    return {\r\n        render: function () {\r\n            return jsx_runtime_1.jsx(\"li\", { children: props.text }, void 0);\r\n        },\r\n    };\r\n}\r\nexports.TodoListItem = TodoListItem;\r\nfunction AddTodo(props) {\r\n    var input = {};\r\n    function saveTodo() {\r\n        var inputEl = input.value;\r\n        if (inputEl) {\r\n            props.onAdd(inputEl.value);\r\n            inputEl.value = \"\";\r\n            inputEl.focus();\r\n        }\r\n    }\r\n    // Add the todo when enter is pressed\r\n    function onKeyPress(e) {\r\n        if (e.key === \"Enter\") {\r\n            saveTodo();\r\n        }\r\n    }\r\n    return {\r\n        render: function () {\r\n            return (jsx_runtime_1.jsxs(\"div\", { children: [jsx_runtime_1.jsx(\"input\", { onkeypress: onKeyPress, type: \"text\", ref: input }, void 0),\r\n                    jsx_runtime_1.jsx(\"button\", __assign({ onclick: saveTodo }, { children: \"Add me!\" }), void 0)] }, void 0));\r\n        },\r\n    };\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.rerender = exports.hydrate = exports.mount = exports.setCustomEnv = exports.shallowRender = exports.renderToString = void 0;\r\nvar render_to_string_1 = require(\"./render-to-string\");\r\nObject.defineProperty(exports, \"renderToString\", { enumerable: true, get: function () { return render_to_string_1.renderToString; } });\r\nObject.defineProperty(exports, \"shallowRender\", { enumerable: true, get: function () { return render_to_string_1.shallowRender; } });\r\n/*\r\n  The element types we care about.\r\n  As defined by the standards.\r\n*/\r\nconst ELEMENT_NODE_TYPE = 1;\r\nconst ATTRIBUTE_NODE_TYPE = 2;\r\nconst TEXT_NODE_TYPE = 3;\r\nconst documentObject = globalThis ? globalThis.document : document;\r\nconst windowObject = globalThis ? globalThis : window;\r\nlet env = {\r\n    window: windowObject,\r\n    document: documentObject,\r\n};\r\nfunction setCustomEnv(value) {\r\n    env = value;\r\n}\r\nexports.setCustomEnv = setCustomEnv;\r\n/*\r\n  This is the main render function.\r\n  forgoNode is the node to render.\r\n  \r\n  node is an existing node to which the element needs to be rendered (if rerendering)\r\n  May not always be passed in, like for first render or when no compatible node exists.\r\n\r\n  statesToAttach is the list of Component State objects which will be attached to the element.\r\n*/\r\nfunction render(forgoNode, node, pendingAttachStates, fullRerender) {\r\n    // Just a string\r\n    if (!isForgoElement(forgoNode)) {\r\n        return renderString(stringOfPrimitiveNode(forgoNode), node, pendingAttachStates, fullRerender);\r\n    }\r\n    // HTML Element\r\n    else if (typeof forgoNode.type === \"string\") {\r\n        return renderDOMElement(forgoNode, node, pendingAttachStates, fullRerender);\r\n    }\r\n    // Custom Component.\r\n    // We don't renderChildren since that is the CustomComponent's prerogative.\r\n    else {\r\n        return renderCustomComponent(forgoNode, node, pendingAttachStates, fullRerender);\r\n    }\r\n}\r\n/*\r\n  Render a string.\r\n  \r\n  Such as in the render function below:\r\n  function MyComponent() {\r\n    return {\r\n      render() {\r\n        return \"Hello world\"\r\n      }\r\n    }\r\n  }\r\n*/\r\nfunction renderString(text, node, pendingAttachStates, fullRerender) {\r\n    var _a;\r\n    // Text nodes will always be recreated\r\n    const textNode = env.document.createTextNode(text);\r\n    attachProps(text, textNode, pendingAttachStates);\r\n    if (node) {\r\n        // If there are old component states, we might need to unmount some of em.\r\n        // After comparing with the new states.\r\n        const oldComponentStates = (_a = getForgoState(node)) === null || _a === void 0 ? void 0 : _a.components;\r\n        if (oldComponentStates) {\r\n            unloadIncompatibleStates(pendingAttachStates, oldComponentStates);\r\n        }\r\n        node.replaceWith(textNode);\r\n    }\r\n    return { node: textNode };\r\n}\r\n/*\r\n  Render a DOM element.\r\n  \r\n  Such as in the render function below:\r\n  function MyComponent() {\r\n    return {\r\n      render() {\r\n        return <div>Hello world</div>\r\n      }\r\n    }\r\n  }\r\n*/\r\nfunction renderDOMElement(forgoElement, node, pendingAttachStates, fullRerender) {\r\n    var _a;\r\n    if (node) {\r\n        let nodeToBindTo;\r\n        // If there are old component states, we might need to unmount some of em.\r\n        // After comparing with the new states.\r\n        const oldComponentStates = (_a = getForgoState(node)) === null || _a === void 0 ? void 0 : _a.components;\r\n        if (oldComponentStates) {\r\n            unloadIncompatibleStates(pendingAttachStates, oldComponentStates);\r\n        }\r\n        // if the nodes are not of the same of the same type, we need to replace.\r\n        if (node.nodeType === TEXT_NODE_TYPE ||\r\n            (node.tagName &&\r\n                node.tagName.toLowerCase() !== forgoElement.type)) {\r\n            const newElement = env.document.createElement(forgoElement.type);\r\n            node.replaceWith(newElement);\r\n            nodeToBindTo = newElement;\r\n        }\r\n        else {\r\n            nodeToBindTo = node;\r\n        }\r\n        attachProps(forgoElement, nodeToBindTo, pendingAttachStates);\r\n        renderChildNodes(forgoElement, nodeToBindTo, fullRerender);\r\n        return { node: nodeToBindTo };\r\n    }\r\n    else {\r\n        // There was no node passed in, so create a new element.\r\n        const newElement = env.document.createElement(forgoElement.type);\r\n        if (forgoElement.props.ref) {\r\n            forgoElement.props.ref.value = newElement;\r\n        }\r\n        attachProps(forgoElement, newElement, pendingAttachStates);\r\n        renderChildNodes(forgoElement, newElement, fullRerender);\r\n        return { node: newElement };\r\n    }\r\n}\r\n/*\r\n  Render a Custom Component\r\n  Such as <MySideBar size=\"large\" />\r\n*/\r\nfunction renderCustomComponent(forgoElement, node, pendingAttachStates, fullRerender) {\r\n    if (node) {\r\n        const state = getExistingForgoState(node);\r\n        const componentIndex = pendingAttachStates.length;\r\n        const savedComponentState = state.components[componentIndex];\r\n        const hasCompatibleState = savedComponentState && savedComponentState.ctor === forgoElement.type;\r\n        if (!hasCompatibleState) {\r\n            // We have to create a new component\r\n            const args = { element: { componentIndex } };\r\n            const ctor = forgoElement.type;\r\n            const component = ctor(forgoElement.props);\r\n            // Create new component state\r\n            // ... and push it to pendingAttachStates\r\n            const componentState = {\r\n                key: forgoElement.key,\r\n                ctor,\r\n                component,\r\n                props: forgoElement.props,\r\n                args,\r\n            };\r\n            const statesToAttach = pendingAttachStates.concat(componentState);\r\n            // Create an element by rendering the component\r\n            const newForgoElement = component.render(forgoElement.props, args);\r\n            // Pass it on for rendering...\r\n            return render(newForgoElement, node, statesToAttach, fullRerender);\r\n        }\r\n        // We have compatible state, and this is a rerender\r\n        else {\r\n            if (fullRerender ||\r\n                havePropsChanged(savedComponentState.props, forgoElement.props)) {\r\n                const args = {\r\n                    element: { componentIndex: pendingAttachStates.length },\r\n                };\r\n                // Since we have compatible state already stored,\r\n                // we'll push the savedComponentState into pending states for later attachment.\r\n                const statesToAttach = pendingAttachStates.concat(Object.assign(Object.assign({}, savedComponentState), { props: forgoElement.props }));\r\n                // Get a new element by calling render on existing component.\r\n                const newForgoElement = savedComponentState.component.render(forgoElement.props, args);\r\n                // Pass it on for rendering...\r\n                return render(newForgoElement, node, statesToAttach, fullRerender);\r\n            }\r\n            else {\r\n                return { node };\r\n            }\r\n        }\r\n    }\r\n    // First time render\r\n    else {\r\n        const args = { element: { componentIndex: 0 } };\r\n        const ctor = forgoElement.type;\r\n        const component = ctor(forgoElement.props);\r\n        // We'll have to create a new component state\r\n        // ... and push it to pendingAttachStates\r\n        const componentState = {\r\n            key: forgoElement.key,\r\n            ctor,\r\n            component,\r\n            props: forgoElement.props,\r\n            args,\r\n        };\r\n        const statesToAttach = pendingAttachStates.concat(componentState);\r\n        const newForgoElement = component.render(forgoElement.props, args);\r\n        // We have no node to render to yet. So pass undefined for the node.\r\n        return render(newForgoElement, undefined, statesToAttach, fullRerender);\r\n    }\r\n}\r\n/*\r\n  Loop through and render child nodes of a forgo DOM element.\r\n\r\n  In the following example, if the forgoElement represents the 'parent' node, render the child nodes.\r\n  eg:\r\n    <div id=\"parent\">\r\n      <MyTopBar />\r\n      <p id=\"first-child\">some content goes here...</p>\r\n      <MyFooter />\r\n    </div>\r\n\r\n  The parentElement is the actual DOM element which corresponds to forgoElement.\r\n*/\r\nfunction renderChildNodes(forgoElement, parentElement, fullRerender) {\r\n    const { children: forgoChildrenObj } = forgoElement.props;\r\n    const childNodes = parentElement.childNodes;\r\n    // Children will not be an array if single item\r\n    const forgoChildren = (forgoChildrenObj !== undefined\r\n        ? Array.isArray(forgoChildrenObj)\r\n            ? forgoChildrenObj\r\n            : [forgoChildrenObj]\r\n        : []);\r\n    let forgoChildIndex = 0;\r\n    if (forgoChildren) {\r\n        for (forgoChildIndex = 0; forgoChildIndex < forgoChildren.length; forgoChildIndex++) {\r\n            const forgoChild = forgoChildren[forgoChildIndex];\r\n            // We have to find a matching node candidate, if any.\r\n            if (!isForgoElement(forgoChild)) {\r\n                // If the first node is a text node, we could pass that along.\r\n                // No need to replace here, callee does that.\r\n                if (childNodes[forgoChildIndex] &&\r\n                    childNodes[forgoChildIndex].nodeType === TEXT_NODE_TYPE) {\r\n                    render(stringOfPrimitiveNode(forgoChild), childNodes[forgoChildIndex], [], fullRerender);\r\n                }\r\n                // But otherwise, don't pass a replacement node. Just insert instead.\r\n                else {\r\n                    const { node } = render(stringOfPrimitiveNode(forgoChild), undefined, [], fullRerender);\r\n                    parentElement.insertBefore(node, childNodes[forgoChildIndex]);\r\n                }\r\n            }\r\n            else {\r\n                const findResult = typeof forgoChild.type === \"string\"\r\n                    ? findReplacementCandidateForDOMElement(forgoChild, childNodes, forgoChildIndex)\r\n                    : findReplacementCandidateForCustomComponent(forgoChild, childNodes, forgoChildIndex);\r\n                if (findResult.found) {\r\n                    for (let i = forgoChildIndex; i < findResult.index; i++) {\r\n                        unloadNode(parentElement, childNodes[i]);\r\n                    }\r\n                    render(forgoChild, childNodes[forgoChildIndex], [], fullRerender);\r\n                }\r\n                else {\r\n                    const { node } = render(forgoChild, undefined, [], fullRerender);\r\n                    if (childNodes.length > forgoChildIndex) {\r\n                        parentElement.insertBefore(node, childNodes[forgoChildIndex]);\r\n                    }\r\n                    else {\r\n                        parentElement.appendChild(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Now we gotta remove old nodes which aren't being used.\r\n    // Everything after forgoChildIndex must go.\r\n    for (let i = forgoChildIndex; i < childNodes.length; i++) {\r\n        unloadNode(parentElement, childNodes[i]);\r\n    }\r\n}\r\n/*\r\n  Unloads components from a node list\r\n  This does:\r\n  a) Remove the node\r\n  b) Calls unload on all attached components\r\n*/\r\nfunction unloadNode(parentElement, node) {\r\n    parentElement.removeChild(node);\r\n    const state = getForgoState(node);\r\n    if (state) {\r\n        for (const componentState of state.components) {\r\n            if (componentState.component.unmount) {\r\n                componentState.component.unmount();\r\n            }\r\n        }\r\n    }\r\n}\r\n/*\r\n  When states is attached to a new node,\r\n  or when states are reattached, some of the old component states need to go away.\r\n  The corresponding components will need to be unmounted.\r\n\r\n  While rendering, the component gets reused if the ctor is the same.\r\n  If the ctor is different, the component is discarded. And hence needs to be unmounted.\r\n  So we check the ctor type in old and new.\r\n*/\r\nfunction unloadIncompatibleStates(newStates, oldStates) {\r\n    let i = 0;\r\n    for (const newState of newStates) {\r\n        if (oldStates.length > i) {\r\n            const oldState = oldStates[i];\r\n            if (oldState.ctor !== newState.ctor) {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    for (let j = i; j < oldStates.length; j++) {\r\n        const oldState = oldStates[j];\r\n        if (oldState.component.unmount) {\r\n            oldState.component.unmount();\r\n        }\r\n    }\r\n}\r\n/*\r\n  When we try to find replacement candidates for DOM nodes,\r\n  we try to:\r\n    a) match by the key\r\n    b) match by the tagname\r\n*/\r\nfunction findReplacementCandidateForDOMElement(forgoElement, nodes, searchNodesFrom) {\r\n    if (forgoElement.key) {\r\n        for (let i = searchNodesFrom; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n            const stateOnNode = getForgoState(node);\r\n            if ((stateOnNode === null || stateOnNode === void 0 ? void 0 : stateOnNode.key) === forgoElement.key) {\r\n                return { found: true, index: i };\r\n            }\r\n        }\r\n        return { found: false };\r\n    }\r\n    else {\r\n        for (let i = searchNodesFrom; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n            if (node.nodeType === ELEMENT_NODE_TYPE) {\r\n                const element = node;\r\n                if (element.tagName.toLowerCase() === forgoElement.type) {\r\n                    return { found: true, index: i };\r\n                }\r\n            }\r\n        }\r\n        return { found: false };\r\n    }\r\n}\r\n/*\r\n  When we try to find replacement candidates for Custom Components,\r\n  we try to:\r\n    a) match by the key\r\n    b) match by the component constructor\r\n*/\r\nfunction findReplacementCandidateForCustomComponent(forgoElement, nodes, searchNodesFrom) {\r\n    if (forgoElement.key) {\r\n        for (let i = searchNodesFrom; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n            const stateOnNode = getForgoState(node);\r\n            if (stateOnNode && stateOnNode.components.length > 0) {\r\n                if (stateOnNode.components[0].key === forgoElement.key) {\r\n                    return { found: true, index: i };\r\n                }\r\n            }\r\n        }\r\n        return { found: false };\r\n    }\r\n    else {\r\n        for (let i = searchNodesFrom; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n            const stateOnNode = getForgoState(node);\r\n            if (stateOnNode && stateOnNode.components.length > 0) {\r\n                if (stateOnNode.components[0].ctor === forgoElement.type) {\r\n                    return { found: true, index: i };\r\n                }\r\n            }\r\n        }\r\n        return { found: false };\r\n    }\r\n}\r\n/*\r\n  Attach props from the forgoElement on to the DOM node.\r\n  We also need to attach states from pendingAttachStates\r\n*/\r\nfunction attachProps(forgoNode, node, pendingAttachStates) {\r\n    if (isForgoElement(forgoNode)) {\r\n        // We're gonna keep this simple.\r\n        // Attach everything as is.\r\n        const entries = Object.entries(forgoNode.props);\r\n        for (const [key, value] of entries) {\r\n            if (key !== \"children\") {\r\n                node[key] = value;\r\n            }\r\n        }\r\n    }\r\n    // We have to inject node into the args object.\r\n    // components are already holding a reference to the args object.\r\n    // They don't know yet that args.element.node is undefined.\r\n    for (const state of pendingAttachStates) {\r\n        state.args.element.node = node;\r\n    }\r\n    // Now attach the internal forgo state.\r\n    const state = {\r\n        key: isForgoElement(forgoNode) ? forgoNode.key : undefined,\r\n        components: pendingAttachStates,\r\n    };\r\n    setForgoState(node, state);\r\n}\r\n/*\r\n  Compare old props and new props.\r\n  We don't rerender if props remain the same.\r\n*/\r\nfunction havePropsChanged(oldProps, newProps) {\r\n    const oldKeys = Object.keys(oldProps);\r\n    const newKeys = Object.keys(newProps);\r\n    return (oldKeys.length !== newKeys.length ||\r\n        oldKeys.some((key) => oldProps[key] !== newProps[key]));\r\n}\r\n/*\r\n  Mount will render the DOM as a child of the specified container element.\r\n*/\r\nfunction mount(forgoNode, parentElement) {\r\n    if (parentElement) {\r\n        const { node } = render(forgoNode, undefined, [], true);\r\n        parentElement.appendChild(node);\r\n    }\r\n    else {\r\n        throw new Error(`Mount was called on a non-element (${parentElement}).`);\r\n    }\r\n}\r\nexports.mount = mount;\r\n/*\r\n  Mount will hydrate the DOM as a child of the specified container element.\r\n*/\r\nfunction hydrate(forgoNode, parentElement, options) {\r\n    const opts = options || {};\r\n    if (parentElement) {\r\n        let root;\r\n        if (typeof opts.root === \"function\") {\r\n            root = opts.root();\r\n        }\r\n        else if (typeof opts.root === \"object\") {\r\n            root = opts.root;\r\n        }\r\n        else {\r\n            root = parentElement.querySelector(opts.root || \"[forgo-root]\");\r\n        }\r\n        if (!root) {\r\n            throw new Error(\"Could not locate root to hydrate into.\");\r\n        }\r\n        const { node } = render(forgoNode, undefined, [], false);\r\n        parentElement.replaceChild(node, root);\r\n    }\r\n    else {\r\n        throw new Error(`Mount was called on a non-element (${parentElement}).`);\r\n    }\r\n}\r\nexports.hydrate = hydrate;\r\n/*\r\n  Code inside a component will call rerender whenever it wants to rerender.\r\n  The following function is what they'll need to call.\r\n\r\n  Given only a DOM element, how do we know what component to render?\r\n  We'll fetch all that information from the state information stored on the element.\r\n\r\n  This is attached to a node inside a NodeAttachedState structure.\r\n*/\r\nfunction rerender(element, props = undefined, fullRerender = true) {\r\n    if (element && element.node) {\r\n        const state = getForgoState(element.node);\r\n        if (state) {\r\n            const component = state.components[element.componentIndex];\r\n            const effectiveProps = typeof props !== \"undefined\" ? props : component.props;\r\n            const forgoNode = component.component.render(effectiveProps, component.args);\r\n            const statesToAttach = state.components\r\n                .slice(0, element.componentIndex)\r\n                .concat(Object.assign(Object.assign({}, component), { props: effectiveProps }));\r\n            render(forgoNode, element.node, statesToAttach, fullRerender);\r\n        }\r\n        else {\r\n            throw new Error(`Rerender was called on an element which was never seen before.`);\r\n        }\r\n    }\r\n}\r\nexports.rerender = rerender;\r\n/*\r\n  ForgoNodes can be primitive types.\r\n  Convert all primitive types to their string representation.\r\n*/\r\nfunction stringOfPrimitiveNode(node) {\r\n    return typeof node === \"undefined\" ? \"undefined\" : node.toString();\r\n}\r\n/*\r\n  Nodes could be strings, numbers, booleans etc.\r\n  Treat them as strings.\r\n*/\r\nfunction isForgoElement(node) {\r\n    return (typeof node !== \"undefined\" && node.__is_forgo_element__ === true);\r\n}\r\n/*\r\n  Get the state (NodeAttachedState) saved into an element.\r\n*/\r\nfunction getForgoState(node) {\r\n    return node.__forgo;\r\n}\r\n/*\r\n  Same as above, but will never be undefined. (Caller makes sure.)\r\n*/\r\nfunction getExistingForgoState(node) {\r\n    return node.__forgo;\r\n}\r\n/*\r\n  Sets the state (NodeAttachedState) on an element.\r\n*/\r\nfunction setForgoState(node, state) {\r\n    node.__forgo = state;\r\n}\r\n//# sourceMappingURL=index.js.map","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.shallowRender = exports.renderToString = void 0;\r\nconst { encodeEntities, indent, isLargeString, styleObjToCss, getChildren, } = require(\"preact-render-to-string/src/util\");\r\nconst SHALLOW = { shallow: true };\r\n// components without names, kept as a hash for later comparison to return consistent UnnamedComponentXX names.\r\nconst UNNAMED = [];\r\nconst VOID_ELEMENTS = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/;\r\n/**\r\n * Render Preact JSX + Components to an HTML string.\r\n */\r\nrenderToString.render = renderToString;\r\nlet shallowRender = (vnode, options) => renderToString(vnode, Object.assign(Object.assign({}, options), SHALLOW));\r\nexports.shallowRender = shallowRender;\r\nfunction renderToString(vnode, options) {\r\n    const res = _renderToString(vnode, options);\r\n    return res;\r\n}\r\nexports.renderToString = renderToString;\r\n/** The default export is an alias of `render()`. */\r\nfunction _renderToString(vnode, options, inner, isSvgMode, selectValue) {\r\n    if (vnode == null || typeof vnode === \"boolean\") {\r\n        return \"\";\r\n    }\r\n    // wrap array nodes in Fragment\r\n    if (Array.isArray(vnode)) {\r\n        // vnode = createElement(Fragment, null, vnode);\r\n        throw new Error(\"Array vnode not yet supported\");\r\n    }\r\n    const forgoNode = vnode;\r\n    let nodeName = forgoNode.type, props = forgoNode.props, isComponent = false;\r\n    let opts = options || {};\r\n    let pretty = opts.pretty, indentChar = pretty && typeof pretty === \"string\" ? pretty : \"\\t\";\r\n    // #text nodes\r\n    if (typeof vnode !== \"object\" && !nodeName) {\r\n        return encodeEntities(vnode);\r\n    }\r\n    // components\r\n    if (typeof nodeName === \"function\") {\r\n        isComponent = true;\r\n        if (opts.shallow && (inner || opts.renderRootComponent === false)) {\r\n            nodeName = getComponentName(nodeName);\r\n        }\r\n        else if (false /*nodeName === Fragment*/) {\r\n            // TODO: Implement fragments\r\n            // let rendered = \"\";\r\n            // let children = [];\r\n            // getChildren(children, vnode.props.children);\r\n            // for (let i = 0; i < children.length; i++) {\r\n            //   rendered +=\r\n            //     (i > 0 && pretty ? \"\\n\" : \"\") +\r\n            //     _renderToString(\r\n            //       children[i],\r\n            //       opts,\r\n            //       opts.shallowHighOrder !== false,\r\n            //       isSvgMode,\r\n            //       selectValue\r\n            //     );\r\n            // }\r\n            // return rendered;\r\n        }\r\n        else {\r\n            let rendered;\r\n            // stateless functional components\r\n            rendered = nodeName\r\n                .call(null, props)\r\n                .render.call(null, props, null);\r\n            return _renderToString(rendered, opts, opts.shallowHighOrder !== false, isSvgMode, selectValue);\r\n        }\r\n    }\r\n    // render JSX to HTML\r\n    let s = \"\", propChildren, html;\r\n    if (props) {\r\n        let attrs = Object.keys(props);\r\n        for (let i = 0; i < attrs.length; i++) {\r\n            let name = attrs[i], v = props[name];\r\n            if (name === \"children\") {\r\n                propChildren = v;\r\n                continue;\r\n            }\r\n            if (name.match(/[\\s\\n\\\\/='\"\\0<>]/))\r\n                continue;\r\n            if (!false &&\r\n                (name === \"key\" ||\r\n                    name === \"ref\" ||\r\n                    name === \"__self\" ||\r\n                    name === \"__source\" ||\r\n                    name === \"defaultValue\"))\r\n                continue;\r\n            if (name === \"className\") {\r\n                if (props.class)\r\n                    continue;\r\n                name = \"class\";\r\n            }\r\n            else if (isSvgMode && name.match(/^xlink:?./)) {\r\n                name = name.toLowerCase().replace(/^xlink:?/, \"xlink:\");\r\n            }\r\n            if (name === \"htmlFor\") {\r\n                if (props.for)\r\n                    continue;\r\n                name = \"for\";\r\n            }\r\n            if (name === \"style\" && v && typeof v === \"object\") {\r\n                v = styleObjToCss(v);\r\n            }\r\n            // always use string values instead of booleans for aria attributes\r\n            // also see https://github.com/preactjs/preact/pull/2347/files\r\n            if (name[0] === \"a\" && name[1] === \"r\" && typeof v === \"boolean\") {\r\n                v = String(v);\r\n            }\r\n            if (name === \"dangerouslySetInnerHTML\") {\r\n                html = v && v.__html;\r\n            }\r\n            else if (nodeName === \"textarea\" && name === \"value\") {\r\n                // <textarea value=\"a&b\"> --> <textarea>a&amp;b</textarea>\r\n                propChildren = v;\r\n            }\r\n            else if ((v || v === 0 || v === \"\") && typeof v !== \"function\") {\r\n                if (v === true || v === \"\") {\r\n                    v = name;\r\n                    // in non-xml mode, allow boolean attributes\r\n                    if (true) {\r\n                        s += \" \" + name;\r\n                        continue;\r\n                    }\r\n                }\r\n                if (name === \"value\") {\r\n                    if (nodeName === \"select\") {\r\n                        selectValue = v;\r\n                        continue;\r\n                    }\r\n                    else if (nodeName === \"option\" && selectValue == v) {\r\n                        s += ` selected`;\r\n                    }\r\n                }\r\n                s += ` ${name}=\"${encodeEntities(v)}\"`;\r\n            }\r\n        }\r\n    }\r\n    // account for >1 multiline attribute\r\n    if (pretty) {\r\n        let sub = s.replace(/^\\n\\s*/, \" \");\r\n        if (sub !== s && !~sub.indexOf(\"\\n\"))\r\n            s = sub;\r\n        else if (pretty && ~s.indexOf(\"\\n\"))\r\n            s += \"\\n\";\r\n    }\r\n    s = `<${nodeName}${s}>`;\r\n    if (String(nodeName).match(/[\\s\\n\\\\/='\"\\0<>]/))\r\n        throw new Error(`${nodeName} is not a valid HTML tag name in ${s}`);\r\n    let isVoid = String(nodeName).match(VOID_ELEMENTS);\r\n    let pieces = [];\r\n    let children = undefined;\r\n    if (html) {\r\n        // if multiline, indent.\r\n        if (pretty && isLargeString(html)) {\r\n            html = \"\\n\" + indentChar + indent(html, indentChar);\r\n        }\r\n        s += html;\r\n    }\r\n    else if (propChildren != null &&\r\n        getChildren((children = []), propChildren).length) {\r\n        let hasLarge = pretty && !!~s.indexOf(\"\\n\");\r\n        let lastWasText = false;\r\n        for (let i = 0; i < children.length; i++) {\r\n            let child = children[i];\r\n            if (child != null && child !== false) {\r\n                let childSvgMode = nodeName === \"svg\"\r\n                    ? true\r\n                    : nodeName === \"foreignObject\"\r\n                        ? false\r\n                        : isSvgMode, ret = _renderToString(child, opts, opts.shallowHighOrder !== false, childSvgMode, selectValue);\r\n                if (pretty && !hasLarge && isLargeString(ret))\r\n                    hasLarge = true;\r\n                // Skip if we received an empty string\r\n                if (ret) {\r\n                    if (pretty) {\r\n                        let isText = ret.length > 0 && ret[0] != \"<\";\r\n                        // We merge adjacent text nodes, otherwise each piece would be printed\r\n                        // on a new line.\r\n                        if (lastWasText && isText) {\r\n                            pieces[pieces.length - 1] += ret;\r\n                        }\r\n                        else {\r\n                            pieces.push(ret);\r\n                        }\r\n                        lastWasText = isText;\r\n                    }\r\n                    else {\r\n                        pieces.push(ret);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (pretty && hasLarge) {\r\n            for (let i = pieces.length; i--;) {\r\n                pieces[i] = \"\\n\" + indentChar + indent(pieces[i], indentChar);\r\n            }\r\n        }\r\n    }\r\n    if (pieces.length || html) {\r\n        s += pieces.join(\"\");\r\n    }\r\n    else if (opts && opts.xml) {\r\n        return s.substring(0, s.length - 1) + \" />\";\r\n    }\r\n    if (isVoid && !children && !html) {\r\n        s = s.replace(/>$/, \" />\");\r\n    }\r\n    else {\r\n        if (pretty && ~s.indexOf(\"\\n\"))\r\n            s += \"\\n\";\r\n        s += `</${nodeName}>`;\r\n    }\r\n    return s;\r\n}\r\nfunction getComponentName(component) {\r\n    return (component.displayName ||\r\n        (component !== Function && component.name) ||\r\n        getFallbackComponentName(component));\r\n}\r\nfunction getFallbackComponentName(component) {\r\n    let str = Function.prototype.toString.call(component), name = (str.match(/^\\s*function\\s+([^( ]+)/) || \"\")[1];\r\n    if (!name) {\r\n        // search for an existing indexed name for the given component:\r\n        let index = -1;\r\n        for (let i = UNNAMED.length; i--;) {\r\n            if (UNNAMED[i] === component) {\r\n                index = i;\r\n                break;\r\n            }\r\n        }\r\n        // not found, create a new indexed name:\r\n        if (index < 0) {\r\n            index = UNNAMED.push(component) - 1;\r\n        }\r\n        name = `UnnamedComponent${index}`;\r\n    }\r\n    return name;\r\n}\r\n//# sourceMappingURL=render-to-string.js.map","export function jsxs(type, props, key) {\r\n  return { type, props, key, __is_forgo_element__: true };\r\n}\r\nexport function jsx(type, props, key) {\r\n  return { type, props, key, __is_forgo_element__: true };\r\n}\r\n","// DOM properties that should NOT have \"px\" added when numeric\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;\n\nexport function encodeEntities(s) {\n\tif (typeof s !== 'string') s = String(s);\n\tlet out = '';\n\tfor (let i = 0; i < s.length; i++) {\n\t\tlet ch = s[i];\n\t\t// prettier-ignore\n\t\tswitch (ch) {\n\t\t\tcase '<': out += '&lt;'; break;\n\t\t\tcase '>': out += '&gt;'; break;\n\t\t\tcase '\"': out += '&quot;'; break;\n\t\t\tcase '&': out += '&amp;'; break;\n\t\t\tdefault: out += ch;\n\t\t}\n\t}\n\treturn out;\n}\n\nexport let indent = (s, char) =>\n\tString(s).replace(/(\\n+)/g, '$1' + (char || '\\t'));\n\nexport let isLargeString = (s, length, ignoreLines) =>\n\tString(s).length > (length || 40) ||\n\t(!ignoreLines && String(s).indexOf('\\n') !== -1) ||\n\tString(s).indexOf('<') !== -1;\n\nconst JS_TO_CSS = {};\n\n// Convert an Object style to a CSSText string\nexport function styleObjToCss(s) {\n\tlet str = '';\n\tfor (let prop in s) {\n\t\tlet val = s[prop];\n\t\tif (val != null) {\n\t\t\tif (str) str += ' ';\n\t\t\t// str += jsToCss(prop);\n\t\t\tstr +=\n\t\t\t\tprop[0] == '-'\n\t\t\t\t\t? prop\n\t\t\t\t\t: JS_TO_CSS[prop] ||\n\t\t\t\t\t  (JS_TO_CSS[prop] = prop.replace(/([A-Z])/g, '-$1').toLowerCase());\n\t\t\tstr += ': ';\n\t\t\tstr += val;\n\t\t\tif (typeof val === 'number' && IS_NON_DIMENSIONAL.test(prop) === false) {\n\t\t\t\tstr += 'px';\n\t\t\t}\n\t\t\tstr += ';';\n\t\t}\n\t}\n\treturn str || undefined;\n}\n\n/**\n * Copy all properties from `props` onto `obj`.\n * @param {object} obj Object onto which properties should be copied.\n * @param {object} props Object from which to copy properties.\n * @returns {object}\n * @private\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn obj;\n}\n\n/**\n * Get flattened children from the children prop\n * @param {Array} accumulator\n * @param {any} children A `props.children` opaque object.\n * @returns {Array} accumulator\n * @private\n */\nexport function getChildren(accumulator, children) {\n\tif (Array.isArray(children)) {\n\t\tchildren.reduce(getChildren, accumulator);\n\t} else if (children != null && children !== false) {\n\t\taccumulator.push(children);\n\t}\n\treturn accumulator;\n}\n","module.exports = require(\"fs\");;","module.exports = require(\"http\");;","module.exports = require(\"path\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module\n__webpack_require__(\"./src/server.tsx\");\n// This entry module used 'exports' so it can't be inlined\n"],"sourceRoot":""}